\documentclass[a4paper]{article}

\usepackage[francais]{babel}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{fontspec}
\usepackage[textwidth=17cm,textheight=27cm]{geometry}

%\setlength{\textwidth}{420 pt} 
%\usepackage{amsmath}
%\usepackage{listings}
%\usepackage{moreverb}
%\usepackage{color}
%\usepackage[colorinlistoftodos]{todonotes}
%\usepackage[labelformat=empty]{caption}

\title{Systèmes multi-agents : la bille, le poisson et l'avatar}

\author{Matthieu CARON - Alexandre MOEVI}

\date{\today}

\begin{document}
\maketitle

\section{Architecture et utilisation}
Pour réaliser les différents simulations, il a été décidé d'utiliser la langage Python 3, et non Java 7/8. 

\subsection{Paquetage \texttt{core}}
Avant d'expliquer les trois simulations effectuées, il est nécessaire de présenter le paquetage \texttt{core}. \texttt{core} contient la description générique des objets nécessaires à la mise d'un SMA (système multi-agents). Le paquetage contient cinq classes.
 
\medskip
La classe \texttt{Agent} qui représente un agent du système. Placé dans un \texttt{Environnement}, il connaît ses coordonnées (\texttt{self.x} et \texttt{self.x} en Python, qui correspondent à \texttt{this.x} et \texttt{this.y} en Java). Quand le \texttt{SMA} lui \og donne la parole \fg{}, l'agent décide en fonction de stratégie (méthode \texttt{self.decide()}) puis se met à jour dans son environnement (\texttt{self.update()}). L'agent possède également une méthode \texttt{place\_agent()} qui concerne son affichage dans la fenêtre (classe \texttt{Window}).

\medskip
La classe \texttt{AgentCreator} génère un ou plusieurs \texttt{Agent} du système. Il peut créer un seul type d'agent (uniquement des billes) ou plusieurs types d'agents (poissons et requins).

\medskip
La classe \texttt{Environnement} représente l'espace du système sous forme de grille. Cette grille contient l'ensemble des agents et leur coordonnées. L'environnement peut être torique ou non. 

\medskip
La classe \texttt{SMA} contient la méthode \texttt{run()} qui effectue le tour de parole (ou tick). Dans un tick, le \texttt{SMA} appelle un ou plusieurs agents avec la méthode \texttt{agent.decide()} en fonction du scheduling (\texttt{self.scheduling}). Le scheduling peut être séquentiel, équitable ou aléatoire. Un fois le tour fini, l'affichage est mis à jour avec la méthode \texttt{SMA.updateDisplay()}.

\medskip
La classe \texttt{Window} concerne tout ce qui l'affichage. En se basant sur la bibliothèque graphique \href{https://wiki.python.org/moin/TkInter}{Tkinter}, la classe permet l'affichage du système et l'affichage d'une grille si l'utilisateur le souhaite.

\subsection{Usage}

\$PYTHONPATH, python3, modifier les paramètres dans MainXXX.py, etc.
\section{Simulations}

\subsection{Tube à particules}

La première simulation, le paquetage \texttt{particules}, reproduit le comportement de billes (ou particules) dans un espace. Cet espace peut torique ou non ; s'il ne l'est pas, les particules rebondissent contre les murs. Les particules rebondissent également en collision.

\medskip
La classe \texttt{Bille} hérite la classe \texttt{Agent} du paquetage \texttt{core}. L'agent \texttt{Bille} connaît son environnement, sa position (entiers \texttt{x} et \texttt{y}) et sa direction (vecteur à 2 dimensions \texttt{[a, b]}).

\medskip
La stratégie d'une particule est la suivante :
\begin{itemize}
\item Dans la méthode \texttt{nextPos()}, la particule calcule sa prochaine possible destination en fonction de l'espace torique (apparition de \og l'autre côté \fg{} de l'écran) ou non (rebond).
\item Dans \texttt{decide()}, la particule regarde sa prochaine destination. Si la voie est libre, elle se prépare à se déplacer (\texttt{particule.bougera = True}). Sinon ça veut dire qu'elle essaye de se rendre dans une case occupée par une autre particule : c'est une collision.
\item Dans \texttt{update()}, si la particule peut bouger, elle se met à sa nouvelle position en laissant libre son ancienne place et l'environnement se met à jour.
\end{itemize}

\medskip
Dans le cas d'une collision (\texttt{particule1.collision(particule2)}), la bille \og incidente \fg{}, c'est-à-dire celle qui essaye d'aller dans une case déjà occupée, échange sa direction avec l'autre particule. Il a été décidé que la bille incidente ne se déplace pas pendant le tick de collision, malgré sa nouvelle direction.
 
\begin{figure}[!h]
\centering
\includegraphics[height=7cm]{particules.png}
\caption{Fenêtre d'exécution du programme \texttt{MainBille}. Les billes sont assignées d'une couleur aléatoire et d'un identifiant pour faciliter leur suivi.}
\end{figure}
\subsection{Poissons et requins dans le golfe (du Bénin)}
La deuxième simulation concerne le paquetage \texttt{wator}. Elle a pour but de voir comment des poissons (les agents \texttt{Fish} dans notre simulation) et des requins (agents \texttt{Shark}) cohabitent dans une zone. 

\medskip
Un agent \texttt{Fish} se déplace de façon aléatoire et se reproduit tous les \texttt{fishBreedTime} ticks. Pour se reproduire, le poisson doit se déplacer et donne naissance à un autre poisson sur la case où il était précédemment.

\medskip
Un \texttt{Shark} est affamé, il a \texttt{dontStarve} ticks pour manger un \texttt{Fish}. S'il n'y arrive pas à temps, il meurt. À l'instar du poisson, il peut se reproduire tous les \texttt{sharkBreedTime} et donne naissance à un nouveau requin sur la case qu'il occupait avant.

\medskip
Comme pour l'agent \texttt{Bille} de la simulation précédente, les agents \texttt{Fish} et \texttt{Shark} ont conscience de leur environnement et connaissent leur coordonnées dans l'espace.

\medskip
Avec ces paramètres, le but est de trouver d'atteindre une situation d'équilibre. On veut éviter une pénurie de poissons (plus de poissons = mort des requins affamés = zone vierge de tout animal) et une absence de requins (les poissons vont se reproduire jusqu'à remplir entièrement la zone).

 
\begin{figure}[!h]
\centering
\includegraphics[height=7cm]{1000tours.png}
\caption{Courbes de population.}
\end{figure}

WHY
\subsection{Pac-Man}

\end{document}